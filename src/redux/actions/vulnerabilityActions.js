import { createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';
import toast from 'react-hot-toast';

const API_URL = 'http://localhost:5000/api';

export const fetchVulnerabilities = createAsyncThunk(
  'vulnerabilities/fetchVulnerabilities',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get(`${API_URL}/vulnerabilities`);
      return response.data;
    } catch (error) {
      toast.error('Failed to fetch vulnerabilities');
      return rejectWithValue(error.response?.data?.message || 'Failed to fetch vulnerabilities');
    }
  }
);

export const createVulnerability = createAsyncThunk(
  'vulnerabilities/createVulnerability',
  async (vulnerabilityData, { rejectWithValue }) => {
    try {
      console.log('createVulnerability action called with data:', JSON.stringify(vulnerabilityData, null, 2));
      console.log('API URL being used:', `${API_URL}/vulnerabilities`);
      
      // Log the request configuration
      console.log('Making axios POST request to:', `${API_URL}/vulnerabilities`);
      
      // Add timeout to axios request
      const response = await axios.post(`${API_URL}/vulnerabilities`, vulnerabilityData, {
        timeout: 10000, // 10 seconds timeout
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('API response received:', response);
      // Toast notification is now handled in the component
      return response.data;
    } catch (error) {
      console.error('Error in createVulnerability action:', {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status,
        fullError: error
      });
      
      // Handle different types of errors
      if (error.code === 'ECONNABORTED') {
        return rejectWithValue('Request timed out. Server might be down.');
      }
      
      if (!error.response) {
        return rejectWithValue('Network error. Please check your connection.');
      }
      
      return rejectWithValue(error.response?.data?.message || 'Failed to create vulnerability');
    }
  }
);

export const updateVulnerability = createAsyncThunk(
  'vulnerabilities/updateVulnerability',
  async ({ id, vulnerabilityData }, { rejectWithValue }) => {
    try {
      const response = await axios.put(`${API_URL}/vulnerabilities/${id}`, vulnerabilityData);
      toast.success('Vulnerability updated successfully!');
      return response.data;
    } catch (error) {
      toast.error(error.response?.data?.message || 'Failed to update vulnerability');
      return rejectWithValue(error.response?.data?.message || 'Failed to update vulnerability');
    }
  }
);

export const deleteVulnerability = createAsyncThunk(
  'vulnerabilities/deleteVulnerability',
  async (id, { rejectWithValue }) => {
    try {
      await axios.delete(`${API_URL}/vulnerabilities/${id}`);
      toast.success('Vulnerability deleted successfully!');
      return id;
    } catch (error) {
      toast.error(error.response?.data?.message || 'Failed to delete vulnerability');
      return rejectWithValue(error.response?.data?.message || 'Failed to delete vulnerability');
    }
  }
); 